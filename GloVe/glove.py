import os
current_dir = os.path.dirname(__file__)

from gensim.models import KeyedVectors

# 词嵌入文件
word2vec_output_file = os.path.join(current_dir,'glove_2_word2vec_vectors.txt')
# word2vec_output_file = os.path.join(current_dir,'test.txt')

class GloVeEmbeddings():
    def __init__(self):
        """读取词嵌入文件并加载模型"""
        self.PAD_TAG = 0
        self.UNK_TAG = 1
        self.PAD = "<pad>"
        self.UNK = "<unk>"
        self.model_path = word2vec_output_file

        self.glove_model = self.load_model(self.model_path)
        # self.embedding_dim = self.glove_model.vector_size
        # self.vocab = self.glove_model.index2word
    
    def load_model(self, model_path):
        """加载GloVe模型"""
        return KeyedVectors.load_word2vec_format(model_path, binary=False)
    
    def get_embedding_dim(self):
        """获得词嵌入维度"""
        return self.glove_model.vector_size
    
    def get_vector(self, word):
        """根据单词获取词向量"""
        if word in self.glove_model:
            return self.glove_model[word]
        else:
            # 如果单词不在词汇表中，返回<unk>
            return self.glove_model["<unk>"]

    def word2idx(self, sentence, max_len=None):
        """
        把句子转化为数字序列
        :param sentence:[str,str,str]
        :return: [int,int,int]
        """
        if len(sentence) > max_len:
            sentence = sentence[:max_len]
        else:
            sentence = sentence + [self.PAD] * (max_len - len(sentence))  # 填充PAD
        return [self.glove_model.key_to_index.get(i, self.UNK_TAG) for i in sentence]
    
    def idx2word(self, incides):
        """
        把数字序列转化为字符
        :param incides: [int,int,int]
        :return: [str,str,str]
        """
        return [self.glove_model.index_to_key[i] for i in incides]
    
    def idx2vector(self, incides):
        """
        把数字序列转化为词向量
        :param incides: [int,int,int]
        :return: [float,float,float]
        """
        sentence = self.idx2word(incides)
        return [ self.glove_model[word] for word in sentence]
