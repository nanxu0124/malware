import os
import torch
from tqdm import tqdm
from torch.optim import Adam
import torch.nn.functional as F
from sklearn.metrics import recall_score, f1_score, accuracy_score, precision_score
from OS_CNN_Bi_LSTM import OS_CNN_Bi_LSTM
from utils.utils import device, model_save, save_loss, model_info_save, create_folder
from OS_CNN_Structure_build import generate_layer_parameter_list

def trainModel(train_loader, test_loader, hyperparameters):
    print("OS_CNN_Bi_LSTM Train begin")

    epochs = hyperparameters['num_epochs']
    lr = hyperparameters['learning_rate']
    n_class = hyperparameters['n_class']
    sequence_max_len = hyperparameters['sequence_max_len']
    start_kernel_size = hyperparameters['start_kernel_size']
    Max_kernel_size = hyperparameters['Max_kernel_size']
    paramenter_number_of_layer_list = hyperparameters['paramenter_number_of_layer_list']
    embedding_dim = hyperparameters['embedding_dim']
    lstm_output_dim = hyperparameters['lstm_output_dim']

    linear = hyperparameters['linear']
    dropout = hyperparameters['dropout']

    folder_path = create_folder(os.path.dirname(__file__))

    receptive_field_shape= min(int(sequence_max_len/4), Max_kernel_size)

    layer_parameter_list = generate_layer_parameter_list(start_kernel_size,
                                                             receptive_field_shape,
                                                             paramenter_number_of_layer_list,
                                                             in_channel = 1)
    
    model = OS_CNN_Bi_LSTM(layer_parameter_list, n_class,embedding_dim,lstm_output_dim ,False,linear,dropout).to(device())
    OSCNNBiLSTMLoss = []
    optimizer = Adam(model.parameters(), lr)

    for epoch in range(epochs):
        running_loss = 0.0
        true_labels = []
        predicted_labels = []

        if epoch % 1 == 0 and epoch != 0:
            test(model, test_loader)
        model.train()
        for sequence, matrix, labels in tqdm(train_loader, desc=f'Epoch {epoch + 1}/{epochs}', ncols=100):
            sequence = sequence.unsqueeze_(1).to(device()) # (batch, 1, max_len) (128, 1, 3000)
            matrix = matrix.to(device()) # (batch, seq_len, dim) (128, 3000, 50)
            labels = labels.to(device()) # (batch, ) (128, )
            optimizer.zero_grad()
            outputs = model(sequence, matrix)
            loss = F.cross_entropy(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            true_labels.extend(labels.tolist())
            _, predicted = torch.max(outputs, 1)
            predicted_labels.extend(predicted.tolist())

        avg_loss = running_loss / len(train_loader)
        OSCNNBiLSTMLoss.append(avg_loss)

        recall = recall_score(true_labels, predicted_labels, average='weighted')
        f1 = f1_score(true_labels, predicted_labels, average='weighted')
        accuracy = accuracy_score(true_labels, predicted_labels)
        # precision = precision_score(true_labels, predicted_labels, average='weighted')
        print(f'Epoch [{epoch + 1}/{epochs}] - Loss: {avg_loss:.4f} - Recall: {recall:.4f} - F1-Score: {f1:.4f} - Accuracy: {accuracy:.4f}')

    model_save(folder_path, (model,))
    save_loss(folder_path, OSCNNBiLSTMLoss, "OSCNNLoss")

    recall, f1, accuracy, precision = test(model, test_loader)
    result = {
        "accuracy":accuracy,
        "recall":recall,
        "precision":precision,
        "f1":f1
    }
    model_info_save(folder_path, result, hyperparameters)

    print('OS_CNN_Bi_LSTM Train finished')


def test(model, test_loader):
    model.eval()

    true_labels = []
    predicted_labels = []

    with torch.no_grad():  # 不需要计算梯度
        for sequence, matrix, labels in test_loader:

            sequence = sequence.unsqueeze_(1).to(device())
            matrix = matrix.to(device())
            labels = labels.to(device())
            outputs = model(sequence, matrix)

            _, predicted = torch.max(outputs, 1)
            
            # 保存真实标签和预测标签以计算指标
            true_labels.extend(labels.tolist())
            predicted_labels.extend(predicted.tolist())

    # 计算召回率、F1-Score 和准确度
    recall = recall_score(true_labels, predicted_labels, average='macro')
    f1 = f1_score(true_labels, predicted_labels, average='weighted')
    accuracy = accuracy_score(true_labels, predicted_labels)
    precision = precision_score(true_labels, predicted_labels, average='weighted')

    # 输出测试指标
    print(f'Test Accuracy: {accuracy:.4f}')
    print(f'Test Recall: {recall:.4f}')
    print(f'Test F1-Score: {f1:.4f}')
    print(f'Test precision: {precision:.4f}')

    return recall, f1, accuracy, precision