import os
import torch
from tqdm import tqdm
from torch.optim import Adam
import torch.nn.functional as F
from sklearn.metrics import recall_score, f1_score, accuracy_score, precision_score
from OS_CNN import OS_CNN
from utils.utils import device, model_save, save_loss, model_info_save, create_folder
from OS_CNN_Structure_build import generate_layer_parameter_list

def trainModel(train_loader, test_loader, hyperparameters):
    print("OS_CNN Train begin")

    epochs = hyperparameters['num_epochs']
    lr = hyperparameters['learning_rate']
    n_class = hyperparameters['n_class']
    sequence_max_len = hyperparameters['sequence_max_len']
    start_kernel_size = hyperparameters['start_kernel_size']
    Max_kernel_size = hyperparameters['Max_kernel_size']
    paramenter_number_of_layer_list = hyperparameters['paramenter_number_of_layer_list']

    folder_path = create_folder(os.path.dirname(__file__))

    receptive_field_shape= min(int(sequence_max_len/4), Max_kernel_size)

    layer_parameter_list = generate_layer_parameter_list(start_kernel_size,
                                                             receptive_field_shape,
                                                             paramenter_number_of_layer_list,
                                                             in_channel = 1)
    
    model = OS_CNN(layer_parameter_list, n_class, False).to(device())
    OSCNNLoss = []
    optimizer = Adam(model.parameters(), lr)

    for epoch in range(epochs):
        running_loss = 0.0
        true_labels = []
        predicted_labels = []

        if epoch % 5 == 0 and epoch != 0:
            test(model, test_loader)
        model.train()
        for api, labels in tqdm(train_loader, desc=f'Epoch {epoch + 1}/{epochs}', ncols=100):
            inputs = api.unsqueeze_(1).to(device()) # (batch, max_len) (128, 100)
            labels = labels.to(device()) # (batch, ) (128, )
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = F.cross_entropy(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            true_labels.extend(labels.tolist())
            _, predicted = torch.max(outputs, 1)
            predicted_labels.extend(predicted.tolist())

        avg_loss = running_loss / len(train_loader)
        OSCNNLoss.append(avg_loss)

        recall = recall_score(true_labels, predicted_labels, average='weighted')
        f1 = f1_score(true_labels, predicted_labels, average='weighted')
        accuracy = accuracy_score(true_labels, predicted_labels)
        # precision = precision_score(true_labels, predicted_labels, average='weighted')
        print(f'Epoch [{epoch + 1}/{epochs}] - Loss: {avg_loss:.4f} - Recall: {recall:.4f} - F1-Score: {f1:.4f} - Accuracy: {accuracy:.4f}')

    model_save(folder_path, (model,))
    save_loss(folder_path, OSCNNLoss, "OSCNNLoss")

    recall, f1, accuracy, precision = test(model, test_loader)
    result = {
        "accuracy":accuracy,
        "recall":recall,
        "precision":precision,
        "f1":f1
    }
    model_info_save(folder_path, result, hyperparameters)

    print('OS_CNN Train finished')


def test(model, test_loader):
    model.eval()

    true_labels = []
    predicted_labels = []

    with torch.no_grad():  # 不需要计算梯度
        for api, labels in test_loader:

            # 设置device
            inputs = api.unsqueeze_(1).to(device())
            labels = labels.to(device())

            # 获取模型输出结果
            outputs = model(inputs)

            _, predicted = torch.max(outputs, 1)
            
            # 保存真实标签和预测标签以计算指标
            true_labels.extend(labels.tolist())
            predicted_labels.extend(predicted.tolist())

    # 计算召回率、F1-Score 和准确度
    recall = recall_score(true_labels, predicted_labels, average='macro')
    f1 = f1_score(true_labels, predicted_labels, average='weighted')
    accuracy = accuracy_score(true_labels, predicted_labels)
    precision = precision_score(true_labels, predicted_labels, average='weighted')

    # 输出测试指标
    print(f'Test Accuracy: {accuracy:.4f}')
    print(f'Test Recall: {recall:.4f}')
    print(f'Test F1-Score: {f1:.4f}')
    print(f'Test precision: {precision:.4f}')

    return recall, f1, accuracy, precision