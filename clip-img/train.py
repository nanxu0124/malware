import os
import torch
import clip
from tqdm import tqdm
from torch.optim import Adam
import torch.nn.functional as F
from sklearn.metrics import recall_score, f1_score, accuracy_score, precision_score
from model import CLIPMLP
from utils.utils import device, model_save, save_loss, model_info_save, create_folder

def trainModel(train_loader, test_loader, hyperparameters):
    print("CLIPMLP Train begin")
    epochs = hyperparameters['num_epochs']
    lr = hyperparameters['learning_rate']
    folder_path = create_folder(os.path.dirname(__file__))
    model = CLIPMLP().to(device())
    CLIPMLPLoss = []
    optimizer = Adam(model.parameters(), lr)

    clip_model, preprocess = clip.load("ViT-B/32", device="cuda:1")

    for epoch in range(epochs):
        running_loss = 0.0
        true_labels = []
        predicted_labels = []

        if epoch % 5 == 0 and epoch != 0:
            test(model,clip_model, test_loader)
        model.train()
        for img, labels in tqdm(train_loader, desc=f'Epoch {epoch + 1}/{epochs}', ncols=100):
            inputs = img.to(device())
            labels = labels.to(device())
            with torch.no_grad():
                image_features = clip_model.encode_image(inputs).to(device()).to(torch.float32)
            optimizer.zero_grad()
            outputs = model(image_features)
            loss = F.cross_entropy(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            true_labels.extend(labels.tolist())
            _, predicted = torch.max(outputs, 1)
            predicted_labels.extend(predicted.tolist())

        avg_loss = running_loss / len(train_loader)
        CLIPMLPLoss.append(avg_loss)

        recall = recall_score(true_labels, predicted_labels, average='weighted')
        f1 = f1_score(true_labels, predicted_labels, average='weighted')
        accuracy = accuracy_score(true_labels, predicted_labels)
        # precision = precision_score(true_labels, predicted_labels, average='weighted')
        print(f'Epoch [{epoch + 1}/{epochs}] - Loss: {avg_loss:.4f} - Recall: {recall:.4f} - F1-Score: {f1:.4f} - Accuracy: {accuracy:.4f}')

    model_save(folder_path, (model,))
    save_loss(folder_path, CLIPMLPLoss, "CLIPMLPLoss")

    recall, f1, accuracy, precision = test(model,clip_model, test_loader)
    result = {
        "accuracy":accuracy,
        "recall":recall,
        "precision":precision,
        "f1":f1
    }
    model_info_save(folder_path, result, hyperparameters)

    print('CLIPMLP Train finished')


def test(model,clip_model, test_loader):
    model.eval()

    true_labels = []
    predicted_labels = []

    with torch.no_grad():  # 不需要计算梯度
        for img, labels in test_loader:

            # 设置device
            inputs = img.to(device())
            labels = labels.to(device())
            with torch.no_grad():
                image_features = clip_model.encode_image(inputs).to(device()).to(torch.float32)
            # 获取模型输出结果
            outputs = model(image_features)

            _, predicted = torch.max(outputs, 1)
            
            # 保存真实标签和预测标签以计算指标
            true_labels.extend(labels.tolist())
            predicted_labels.extend(predicted.tolist())

    # 计算召回率、F1-Score 和准确度
    recall = recall_score(true_labels, predicted_labels, average='macro')
    f1 = f1_score(true_labels, predicted_labels, average='weighted')
    accuracy = accuracy_score(true_labels, predicted_labels)
    precision = precision_score(true_labels, predicted_labels, average='weighted')

    # 输出测试指标
    print(f'Test Accuracy: {accuracy:.4f}')
    print(f'Test Recall: {recall:.4f}')
    print(f'Test F1-Score: {f1:.4f}')
    print(f'Test precision: {precision:.4f}')

    return recall, f1, accuracy, precision